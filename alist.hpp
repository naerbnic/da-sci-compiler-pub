//	alist.hpp
// 	definitions for assembly

#if !defined(ALIST_HPP)
#define ALIST_HPP

#if !defined(LIST_HPP)
#include	"list.hpp"
#endif

class ANOpCode;
class ANode;
class OutputFile;

struct AList : List {
	// AList (assembly list) is a list of ANodes (assembly nodes).

	ANOpCode*	nextOp(ANode* start);
					// Return a pointer to the next opcode node after 'start' in
					// the list or NULL if there are none.

	ANOpCode*	findOp(uint op);
					// Return a pointer to the next opcode node if it is opcode
					// 'op', NULL if it isn't.

	Bool			removeOp(uint op);
					// If next opcode in the list is 'op', remove it.

	size_t		size();
					// Return the number of bytes of code generated by the opcodes
					// in this list.

	void			list();
					// List a header for this AList, then invoke the list() methods
					// of each element in the list.

	void			emit(OutputFile*);
					// Invoke the emit() methods of each element in the list.

	size_t		setOffset(size_t ofs);
					// Set the offsets of each element of the list based on the
					// start of the list being at offset 'ofs'.

	void			optimize();
					// Do any possible optimizations on this list.  Currently
					// only applies to subclass CodeList.
};

class FixupList : public AList {
// A FixupList is an AList which has elements in it which need to be relocated
// by the interpreter at load time.  It builds a table of offsets needing
// relocation which is appended to the end of the object code being generated.
public:
	FixupList();
	~FixupList();

	void		clear();
	void		list();
	void		emit(OutputFile*);
	size_t	setOffset(size_t ofs);

	void		incFixups(uint inc = 1) { numFixups += inc; }
					// Increment the number of elements needing fixup.  This is
					// called each time we generate an ANode requiring fixup.

	void		initFixups();
					// Called once the module has been compiled to allocate space
					// for the fixup table based on 'numFixups'.

	void		listFixups();
					// List the fixup table.

	void		emitFixups(OutputFile*);
					// Emit the fixup table to the object file.

	void		addFixup(size_t ofs);
					// The word at offset 'ofs' in the object file needs relocation.
					// Add the offset to the fixup table.

protected:
	uint		numFixups;		// number of locations needing fixup in this AList
	size_t*	fixups;			// pointer to storage for fixup values
	uint		fixIndex;		// index for adding fixups
	size_t	fixOfs;			// offset of start of fixups
};

struct CodeList : FixupList {
// The CodeList class specializes the FixupList class for actual p-code,
// which is the only sort of AList currently optimized.

	void		optimize();
};

extern Bool			addNodesToList;
extern AList*		curList;
extern Bool			noOptimize;
extern Bool			shrink;

#endif
